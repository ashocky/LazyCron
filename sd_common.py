#!/usr/bin/python3
# An autogenerated selection of SurpriseDog's common functions relevant to this project.
# To see how this file was created visit: https://github.com/SurpriseDog/Star-Wrangler
# Written by SurpriseDog at: https://github.com/SurpriseDog

import re
import os
import sys
import csv
import time
import math
import queue
import shutil
import argparse
import threading
import subprocess
from urllib.parse import urlparse
from shutil import get_terminal_size


def bisect_small(lis, num):
	'''Given a sorted list, returns the index of the biggest number smaller than num
	Unlike bisect will never return an index which doesn't exist'''
	end = len(lis) - 1
	for x in range(end + 1):
		if lis[x] > num:
			return max(x - 1, 0)
	else:
		return end


def dict_valtokey(dic, val):
	"Take a dictionary value and return the first key found:"
	for k, v in dic.items():
		if val == v:
			return k
	return None


def read_state(filename, multiline=False, forget=False, verbose=True, cleanup_age=86400):
	"todo make this a class"
	'''
	Maintains open file handles to read the state of a file without wasting resources
	forget =        open a file without maintaing open file handle
	multiline =     Return every stdout line instead of just the first.
	cleanup_age =   Minimum age to keep an old unaccessed file around before cleaning it up
	verbose =       1   Print a notification each time a new file opened
	verbose =       2   Print a notification each time a file is accesssed
	'''

	if verbose >= 2:
		print("Reading:", filename)

	# Open a file and don't add it to the log
	if forget:
		with open(filename, 'r') as f:
			if multiline:
				return list(map(str.strip, f.readlines()))
			else:
				return f.readline().strip()

	# Keep a dictionary of open files
	self = read_state
	now = time.time()
	if not hasattr(self, 'filenames'):
		self.filenames = dict()         # dictionary of filenames to file handles
		self.history = dict()           # When was the last time file was opened?
		self.last_cleanup = now         # Cleanup old files, occassionally
		# There is a limit to the number of open file handles.
		self.limit = 64                 # int(resource.getrlimit(resource.RLIMIT_NOFILE)[0] / 4)

	# Cleanup old unused file handles
	if cleanup_age and now - self.last_cleanup > cleanup_age / 2:
		self.last_cleanup = now
		for name in list(self.history.keys()):
			if name == filename:
				continue
			if now - self.history[name] > cleanup_age:
				print("Removing old file handle:", name)
				f = self.filenames[name]
				del self.filenames[name]
				del self.history[name]
				f.close()

	# Remove files if past the limit of file handles
	if len(self.filenames) > self.limit:
		earliest = sorted(list(self.history.values()))[0]
		name = dict_valtokey(self.history, earliest)
		print("\nToo many open handles! Removing:", name)
		f = self.filenames[name]
		f.close()
		del self.filenames[name]
		del self.history[name]

	# Open the file
	if filename not in self.filenames:
		if verbose:
			print("Opening", '#' + str(len(self.filenames) + 1) + ':', filename)
		try:
			f = open(filename, 'r')
		except BaseException:
			raise ValueError("Could not open: " + filename)
		self.filenames[filename] = f
	else:
		f = self.filenames[filename]
		f.seek(0)
	self.history[filename] = now

	# Return data
	if multiline:
		return list(map(str.strip, f.readlines()))
	else:
		return f.readline().strip()


def search_list(expr, the_list, getfirst=False, func='match', ignorecase=True, searcher=None):
	'''Search for expression in each item in list (or dictionary!)
	getfirst = Return the first value found, otherwise None
	searcher = Custom lamda function'''

	if not searcher:
		# func = dict(search='in').get('search', func)
		# Avoiding regex now in case substring has a regex escape character
		if ignorecase:
			expr = expr.lower()
		if func in ('in', 'search'):
			if ignorecase:
				def searcher(expr, item): 	      # pylint: disable=E0102
					return expr in item.lower()
			else:
				def searcher(expr, item): 		  # pylint: disable=E0102
					return expr in item
		elif func == 'match':
			if ignorecase:
				def searcher(expr, item): 		  # pylint: disable=E0102
					return item.lower().startswith(expr)
			else:
				def searcher(expr, item): 		  # pylint: disable=E0102
					return item.startswith(expr)
		else:
			# Could have nested these, but this is faster.
			raise ValueError("Unknown search type:", func)

	output = []
	for item in the_list:
		if searcher(expr, item):
			if isinstance(the_list, dict):
				output.append(the_list[item])
			else:
				output.append(item)
			if getfirst:
				return output[0]
	return output


def error(*args, header='\nError:', **kargs):
	eprint(*args, header=header, v=3, **kargs)
	sys.exit(1)


def safe_filename(filename, src="/ ", dest="-_", no_http=True, length=200, forbidden="*?\\/:<>|"):
	'''Convert urls and the like to safe filesystem names
	src, dest is the character translation table
	length is the max length allowed, set to 200 so rdiff-backup doesn't get upset
	forbidden characters are deleted'''
	if no_http:
		if filename.startswith("http") or filename.startswith("www."):
			netloc = urlparse(filename).netloc
			filename = filename[filename.find(netloc):]
			filename = re.sub("^www\\.", "", filename)
			filename = filename.strip('/')
	filename = filename.translate(filename.maketrans(src, dest)).strip()
	return ''.join(c for c in filename.strip() if c not in forbidden)[:length]


def joiner(char, *args):
	return char.join(map(str, args))


def mkdir(target, exist_ok=True, **kargs):
	"Make a directory without fuss"
	os.makedirs(target, exist_ok=exist_ok, **kargs)


def sig(num, digits=3):
	"Return number formatted for significant digits"
	if num == 0:
		return '0'
	negative = '-' if num < 0 else ''
	num = abs(float(num))
	power = math.log(num, 10)
	if num < 1:
		num = int(10**(-int(power) + digits) * num)
		return negative + '0.' + '0' * -int(power) + str(int(num)).rstrip('0')
	elif power < digits - 1:
		return negative + ('{0:.' + str(digits) + 'g}').format(num)
	else:
		return negative + str(int(num))


def percent(num, digits=0):
	if not digits:
		return str(int(num * 100)) + '%'
	else:
		return sig(num * 100, digits) + '%'


def sorted_array(array, column=-1, reverse=False):
	"Return sorted 2d array line by line"
	pairs = [(line[column], index) for index, line in enumerate(array)]
	for _val, index in sorted(pairs, reverse=reverse):
		# print(index, val)
		yield array[index]


def avg(lis):
	"Average a list"
	return sum(lis) / len(lis)


def debug_pass(*args, **kargs):         # pylint: disable=unused-argument
	"Drop in replacement to disable debug lines"
	pass    # pylint: disable=unnecessary-pass


def read_file(filename):
	"Read an entire file into text"
	with open(filename, 'r') as f:
		return f.read()


def read_val(file):
	"Read a number from an open file handle"
	file.seek(0)
	return int(file.read())


def trailing_avg(lis, power=0.5):
	"Weighted average that biases the last parts of this list more:"
	total = 0
	weights = 0
	for index, num in enumerate(lis):
		weight = (index + 1)**power
		total += weight * num
		weights += weight
	return total / weights


def chunker(lis, lines=2, overlap=False):
	'''Take a list a return its values n items at a time
	alternate way: zip(*[iter(lis)]*n)'''
	step = 1 if overlap else lines
	for start in range(0, len(lis) - lines + 1, step):
		yield lis[start:start + lines]


def spawn(func, *args, daemon=True, delay=0, **kargs):
	'''Spawn a function to run seperately and return the que
	waits for delay seconds before running
	Get the results with que.get()
	Check if the thread is still running with thread.is_alive()
	replaces fork_cmd, mcall
	print('func=', func, id(func))'''

	def worker():
		if delay:
			time.sleep(delay)
		ret = func(*args, **kargs)
		que.put(ret)

	que = queue.Queue()
	# print('args=', args)
	thread = threading.Thread(target=worker)
	thread.daemon = daemon
	thread.start()
	return que, thread


class _TmanObj():
	"Used for ThreadManager"

	def __init__(self, func, *args, delay=0, **kargs):
		self.start = time.time()
		self.que, self.thread = spawn(func, *args, delay=delay, **kargs)

	def age(self):
		return time.time() - self.start

	def is_alive(self):
		return self.thread.is_alive()


class ThreadManager():
	"Maintain a list of threads and when they were started, query() to see if done."

	def __init__(self):
		self.threads = dict()

	def query(self, func, *args, delay=0, max_age=0, **kargs):
		"Start thread if new, return status, que.get()"
		serial = id(func)

		obj = self.threads.get(serial, None)
		if max_age and obj and obj.age() > max_age:
			print("Thread aged out")
			del obj
			obj = None
		if obj and obj.is_alive():
			print("Can't get results now, we got quilting to do!")
			return False, None
		if obj:
			del self.threads[serial]
			return True, obj.que.get()

		# print("Starting thread!")
		obj = _TmanObj(func, *args, delay=delay, **kargs)
		self.threads[serial] = obj
		return False, None

	def remove(self, func):
		"Remove thread if in dict"
		serial = id(func)
		if serial in self.threads:
			del self.threads[serial]


def read_csv(filename, ignore_comments=True, cleanup=True, headers=None, merge=False, delimiter=',', **kargs):
	'''Read a csv while stripping comments and turning numbers into numbers
	ignore_comments = ignore a leading #
	cleanup = remove quotes and fix numbers
	headers = instead of a list return a dict with headers as keys for columns
	delimiter = seperator between columns.
	If you provide a list it will try each one in turn, but the first option must be a single character
	merge = merge repeated delimiter'''

	def clean(row):
		"Strip all the junk off of csv file"
		if not cleanup:
			return row
		out = []
		for item in row:
			# Cleanup any quote wraps
			item = item.strip()
			if item.startswith("'") and item.endswith("'"):
				item.strip("'")
			if item.startswith('"') and item.endswith('"'):
				item.strip('"')

			# Check if its a number
			if item.lstrip('-').replace('.', '', 1).isdigit():
				if '.' in item:
					item = float(item)
				else:
					item = int(item)
			out.append(item)
		return out

	def get_headers(row):
		if not headers:
			return row

		out = {key: None for key in headers}
		length = len(headers)
		count = 0
		for item in row:
			if count >= length:
				if item:
					print("Warning! Unused items while reading line:", row[count:])
				break
			out[headers[count]] = item
			count += 1
		return out

	with open(filename) as f:
		for line in f.readlines():
			if not line:
				yield get_headers(clean([]))

			if delimiter[0] in line:
				row = next(csv.reader([line], delimiter=delimiter[0], **kargs))
			else:
				for d in delimiter[1:]:
					if d in line:
						# This is fixed in python 3.7 anyway: https://github.com/PyCQA/pylint/issues/3424
						row = next(csv.reader([line.replace(d, delimiter[0])], delimiter=delimiter[0], **kargs))
						print("Using backup delimiter to read line:", repr(d))
						break
				else:
					continue

			if row:
				if merge:
					# Eliminate empty columns
					row = [item for item in row if item]
				if not ignore_comments:
					yield get_headers(clean(row))
				elif not row[0].startswith('#'):
					yield get_headers(clean(row))


def rint(num):
	return str(int(round(num)))


def shell(cmd, **kargs):
	"Return first line of stdout"
	return quickrun(cmd, **kargs)[0].strip()


def undent(text, tab=''):
	return '\n'.join([tab + line.lstrip() for line in text.splitlines()])


def list_get(lis, index, default=''):

	# Fetch a value from a list if it exists, otherwise return default
	# Now accepts negative indexes
	length = len(lis)
	if -length <= index < length:
		return lis[index]
	else:
		return default


def update_parser(lines, parser=None, hidden=False, positionals=False):
	'''
	This is a more intuitive method for adding optional arguments.
	For positional arguments, use the standard syntax.

	Example: basic_args = [\
	('--alias', 'variable_name', type, default),
	"help string",
	...
	]

	group_basic = parser.add_argument_group('Basic Arguments', '')
	update_parser(basic_args, group_basic)

	#You only need to include the arguments required, but you can't skip over any.
		('--alias', '',)        # okay
		('--alias', type,)      # not okay

	#Substitute the word list with a number like 2 to get that number of args required.

	# See what your arugments are producing with:
		auto_cols(sorted([[key, repr(val)] for key, val in (vars(parse_args())).items()]))


	'''

	# Make sure the loop ends on a help string
	if not isinstance(lines[-1], str):
		lines.append("")

	alias = None        #
	varname = None      # Variable Name
	default = None      # Default value
	out = []

	def update():
		nonlocal alias
		"# Update argument to parser:"
		if parser:
			if positionals:
				parser.add_argument(varname, default=default, nargs=nargs, help=msg)
			else:
				alias = '--' + alias
				if typ == bool:
					parser.add_argument(alias, dest=varname, default=default, action=action, help=msg)
				else:
					parser.add_argument(alias, dest=varname, default=default, type=typ,
										nargs=nargs, help=msg, metavar='')
			out.append(dict(alias=alias, dest=varname, typ=typ, default=default, msg=msg))
			# print('alias', alias, 'varname', varname, 'default', default, 'type', typ, 'nargs', nargs)

	for index, args in enumerate(lines):

		# Add help if available
		if isinstance(args, str):
			msg = undent(args.strip())
			if msg and not msg.endswith('.'):
				last = msg.split()[-1]
				if last[-1].isalnum() and not last.startswith('-'):
					msg = msg + '.'
			if default:
				msg += "  Default: " + str(default)

		if hidden:
			# Hide the help text:
			msg = argparse.SUPPRESS

		# If on a new tuple line, add_argument
		if alias or varname:
			update()
			alias = None
			varname = None
			msg = ""

		# Continue if not on a new tuple line
		if isinstance(args, str):
			continue

		# Read the values from the tuple:
		alias = args[0].lstrip('-')

		varname = list_get(args, 1)
		if not varname:
			varname = alias

		default = list_get(args, 3, '')
		typ = list_get(args, 2, type(default))
		if typ == list:
			nargs = '*'
			typ = str
			default = []
		elif isinstance(typ, int):
			nargs = typ
			typ = str
		else:
			nargs = '?'

		if typ == bool:
			if default:
				action = 'store_false'
			else:
				action = 'store_true'
				default = False
		if index == len(lines) - 1:
			update()

	return out


def indenter(*args, header='', level=0, tab=4, wrap=-4, even=False):
	'''Break up text into tabbed lines.
	Wrap at max characters:
		0 = Don't wrap
		negtaive = wrap to terminal width minus wrap
	'''
	if wrap < 0:
		wrap = TERM_WIDTH + wrap

	if type(tab) == int:
		tab = ' ' * tab
	header = str(header) + tab * level
	words = (' '.join(map(str, args))).split(' ')

	lc = float('inf')       # line count
	for cut in range(wrap, -1, -1):
		out = []
		line = ''
		count = 0
		for word in words:
			if count:
				new = line + ' ' + word
			else:
				new = header + word
			count += 1
			if cut and len(new.replace('\t', ' ' * 4)) > cut:
				out.append(line)
				line = header + word
			else:
				line = new
		if line:
			out.append(line)
		if not even:
			return out
		if len(out) > lc:
			return prev
		prev = out.copy()
		lc = len(out)
	return out


def print_columns(args, col_width=20, columns=None, just='left', space=0, wrap=True):
	'''Print columns of col_width size.
	columns = manual list of column widths
	just = justification: left, right or center'''

	just = just[0].lower()
	if not columns:
		columns = [col_width] * len(args)

	output = ""
	_col_count = len(columns)
	extra = []
	for count, section in enumerate(args):
		width = columns[count]
		section = str(section)

		if wrap:
			lines = None
			if len(section) > width - space:
				# print(section, len(section), width)
				# lines = slicer(section, *([width] * (len(section) // width + 1)))
				lines = indenter(section, wrap=width - space)
				if len(lines) >= 2 and len(lines[-1]) <= space:
					lines[-2] += lines[-1]
					lines.pop(-1)
			if '\n' in section:
				lines = section.split('\n')
			if lines:
				section = lines[0]
				for lineno, line in enumerate(lines[1:]):
					if lineno + 1 > len(extra):
						extra.append([''] * len(args))
					extra[lineno][count] = line

		if just == 'l':
			output += section.ljust(width)
		elif just == 'r':
			output += section.rjust(width)
		elif just == 'c':
			output += section.center(width)
	print(output)

	for line in extra:
		print_columns(line, col_width, columns, just, space, wrap=False)


def auto_columns(array, space=4, manual=None, printme=True, wrap=0, crop=None):
	'''Automatically adjust column size
	Takes in a 2d array and prints it neatly
	space = spaces between columns
	manual = dictionary of column adjustments made to space variable
	crop = array of max length for each column, 0 = unlimited
	example: {-1:2} sets the space variable to 2 for the last column
	wrap = wrap at this many columns. 0 = terminal width
	'''
	if not manual:
		manual = dict()

	# Convert generators and map objects:
	array = list(array)

	if crop:
		out = []
		for row in array:
			row = list(row)
			for index, _ in enumerate(row):
				line = str(row[index])
				cut = crop[index]
				if len(line) > cut > 3:
					row[index] = line[:cut-3]+'...'
			out.append(row)
		array = out


	# Fixed so array can have inconsistently sized rows
	col_width = {}
	for row in array:
		row = list(map(str, row))
		for col, _ in enumerate(row):
			length = len(row[col])
			if length > col_width.get(col, 0):
				col_width[col] = length

	col_width = [col_width[key] for key in sorted(col_width.keys())]
	spaces = [space] * len(col_width)
	spaces[-1] = 0

	# Make any manual adjustments
	for col, val in manual.items():
		spaces[col] = val

	col_width = [sum(x) for x in zip(col_width, spaces)]

	# Adjust for line wrap
	max_width = get_terminal_size().columns - 1 # Terminal size
	if wrap:
		max_width = min(max_width, wrap)
	extra = sum(col_width) - max_width          # Amount columns exceed the terminal width

	def fill_remainder():
		"After operation to reduce column sizes, use up any remaining space"
		remain = max_width - sum(col_width)
		for x, _ in enumerate(col_width):
			if remain:
				col_width[x] += 1
				remain -= 1

	if extra > 0:
		# print('extra', extra, 'total', total, 'max_width', max_width)
		# print(col_width, '=', sum(col_width))
		if max(col_width) > 0.5 * sum(col_width):
			# If there's one large column, reduce it
			index = col_width.index(max(col_width))
			col_width[index] -= extra
			if col_width[index] < max_width // len(col_width):
				# However if that's not enough reduce all columns equally
				col_width = [max_width // len(col_width)] * len(col_width)
				fill_remainder()
		else:
			# Otherwise reduce all columns proportionally
			col_width = [int(width * (max_width / (max_width + extra))) for width in col_width]
			fill_remainder()
		# print(col_width, '=', sum(col_width))

	# Turn on for visual representation of columns:
	# print(''.join([str(count) * x  for count, x in enumerate(col_width)]))

	if printme:
		for row in array:
			print_columns(row, columns=col_width, space=0)

	return col_width


class DotDict(dict):
	'''
	Example:
	m = dotdict({'first_name': 'Eduardo'}, last_name='Pool', age=24, sports=['Soccer'])

	Modified from:
	https://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary
	to set unlimited chained .variables like DotDict().tom.bob = 3
	'''

	def __init__(self, *args, default=None, **kwargs):
		super(DotDict, self).__init__(*args, **kwargs)
		for arg in args:
			if isinstance(arg, dict):
				for k, v in arg.items():
					self[k] = v
#
		if kwargs:
			for k, v in kwargs.items():
				self[k] = v
#
	def __getattr__(self, attr):
		if attr in self:
			return self.get(attr)
		else:
			self[attr] = DotDict()
			return self[attr]
#
	def __setattr__(self, key, value):
		self.__setitem__(key, value)
#
	def __contains__(self, key):
		return bool(key in self.__dict__)
#
	def __setitem__(self, key, value):
		super(DotDict, self).__setitem__(key, value)
		self.__dict__.update({key: value})
#
	def __delattr__(self, item):
		self.__delitem__(item)
#
	def __delitem__(self, key):
		super(DotDict, self).__delitem__(key)
		del self.__dict__[key]


class ArgMaster():
	'''
	A wrapper class for ArgumentParser with easy to use arguments. See update_parser() for details.
	sortme will sort all arguments by name (except positionals)
	other arguments are passed onto the ArgumentParser constructor
	'''

	def __init__(self, sortme=True, allow_abbrev=True, usage=None, description=None, **kargs):
		self.sortme = sortme            # Sort all non positionals args
		self.groups = []                # List of all groups
		self.usage = usage				# Usage message
		self.description = description
		self.parser = argparse.ArgumentParser(allow_abbrev=allow_abbrev, add_help=False, **kargs)
		# Allow optionals before positionals:
		self.intermixed = hasattr(self.parser, 'parse_intermixed_args')

	def update(self, args, title=None, sortme=None, **kargs):
		group = self.parser.add_argument_group(title)
		args = update_parser(args, group, **kargs)
		self.groups.append(DotDict(args=args, title=title, sortme=sortme))

	def parse(self, args=None, am_help=True):
		if not args:
			args = sys.argv[1:]

		if not am_help:
			self.parser.add_help = True
			return self.parser.parse_args(args)

		# Match help
		for arg in args:
			if re.match('--*h$|--*help$', arg):
				# help_parser(self.parser)
				self.print_help()
				sys.exit(0)
		try:
			if self.intermixed:
				return self.parser.parse_intermixed_args(args)
			else:
				return self.parser.parse_args(args)
		except SystemExit:
			self.print_help()
			sys.exit(0)

	def print_help(self, show_type=True, wrap=0, tab='  '):
		'''Print a custom help message using only ArgMaster args
		show_type = append the variable type expected after each optional argument.
		--arg <int> <int> will expect 2 integers after the arg
		wrap = word wrap instead of using full terminal. 0 = Terminal width
		sort = sort alphabetically. Positional variables are never sorted.
		To sort individual groups, add a special key: group.sortme = True

		Warning: If your variable is not in a group, it will not be shown!'''

		if self.description:
			print('\n' + self.description)

		if self.usage:
			name = os.path.basename(sys.argv[0])
			print('\n' + "Usage:", name, self.usage)
		final = []
		width = 0                       # Max width of the variables column
		for group in self.groups:
			out = []
			for args in group.args:
				args = DotDict(args)
				msg = args.msg
				if msg == argparse.SUPPRESS:
					continue
				alias = args.alias
				if show_type:
					if args.typ and args.typ != bool:
						if args.typ == list:
							typ = '...'
						else:
							typ = '<' + str(args.typ).replace('class ', '')[2:-2] + '>'
						alias += ' ' + typ
				if len(alias) > width:
					width = len(alias)
				out.append([alias, msg])

			if group.sortme is not None:
				sortme = group.sortme
			else:
				sortme = self.sortme
			if sortme:
				# Sort the group while mainting the order of positional arguments at the top
				positionals = [out.pop(line) for line in range(len(out) - 1, -1, -1) if out[line][0].startswith('<')]
				out.sort()
				out = list(reversed(positionals)) + out
			final.append(out)

		for index, out in enumerate(final):
			group = self.groups[index]
			if out:
				for line, _ in enumerate(out):
					out[line][0] = tab + out[line][0].ljust(width)
				print()
				if group.title:
					print(group.title.rstrip(':') + ':')
				if group.description:
					auto_cols([[tab + group.description]])
				auto_cols(out, wrap=wrap)
		print()


def argfixer():
	'''Fix up args for argparse. Lowers case and turns -args into --args'''
	out = []
	for word in sys.argv:
		if word.startswith('-'):
			word = word.lower()
		if re.match('^-[^-]', word):
			out.append('-' + word)
		else:
			out.append(word)
	return out[1:]


def easy_parse(optionals_list, pos_list=None, **kargs):
	'''
	Simpler way to pass arguments to ArgMaster class.
	All kargs are passed to ArgMaster. See the actual implementation for details.
	'''
	am = ArgMaster(**kargs)
	if pos_list:
		am.update(pos_list, title="Positional Arguments", positionals=True)
	am.update(optionals_list, title="Optional Arguments")
	return am.parse(argfixer())


def check_install(*programs, msg=''):
	'''Check if program is installed (and reccomend procedure to install)
	programs is the list of programs to test
	prints msg if it can't find any'''

	errors = 0
	for program in programs:
		paths = shutil.which(program)
		if not paths:
			errors += 1
			print(program, 'is not installed.')
	if errors:
		if msg:
			if type(msg) == str:
				print("To install type:", msg)
			else:
				print("To install type:")
				for m in msg:
					print('\t' + m)
		else:
			print("Please install to continue...")
		sys.exit(1)


def flatten(tree):
	"Flatten a nested list, tuple or dict of any depth into a flat list"
	# For big data sets use this: https://stackoverflow.com/a/45323085/11343425
	out = []
	if isinstance(tree, dict):
		for key, val in tree.items():
			if type(val) in (list, tuple, dict):
				out += flatten(val)
			else:
				out.append({key: val})

	else:
		for item in tree:
			if type(item) in (list, tuple, dict):
				out += flatten(item)
			else:
				out.append(item)
	return out


def quickrun(*cmd, check=False, encoding='utf-8', errors='replace', mode='w', input=None,	# pylint: disable=W0622
			 verbose=0, testing=False, ofile=None, trifecta=False, hidewarning=False, **kargs):
	'''Run a command, list of commands as arguments or any combination therof and return
	the output is a list of decoded lines.
	check    = if the process exits with a non-zero exit code then quit
	testing  = Print command and don't do anything.
	ofile    = output file
	mode     = output file write mode
	trifecta = return (returncode, stdout, stderr)
	input	 = stdinput (auto converted to bytes)
	'''
	cmd = list(map(str, flatten(cmd)))
	if len(cmd) == 1:
		cmd = cmd[0]

	if testing:
		print("Not running command:", cmd)
		return []

	if verbose:
		print("Running command:", cmd)
		print("               =", ' '.join(cmd))

	if ofile:
		output = open(ofile, mode=mode)
	else:
		output = subprocess.PIPE

	if input:
		if type(input) != bytes:
			input = input.encode()

	#Run the command and get return value
	ret = subprocess.run(cmd, check=check, stdout=output, stderr=output, input=input, **kargs)
	code = ret.returncode
	stdout = ret.stdout.decode(encoding=encoding, errors=errors).splitlines() if ret.stdout else []
	stderr = ret.stderr.decode(encoding=encoding, errors=errors).splitlines() if ret.stderr else []

	if ofile:
		output.close()
		return []

	if trifecta:
		return code, stdout, stderr

	if code and not hidewarning:
		warn("Process returned code:", code)

	for line in stderr:
		print(line)

	return stdout


def gohome():
	os.chdir(os.path.dirname(sys.argv[0]))


class Eprinter:
	'''Drop in replace to print errors if verbose level higher than setup level
	To replace every print statement type: from common import eprint as print

	eprint(v=-1)    # Normally hidden messages
	eprint(v=0)     # Default level
	eprint(v=1)     # Priority messages
	eprint(v=2)     # Warnings
	eprint(v=3)     # Errors
	'''

	# Setup: eprint = Eprinter(<verbosity level>).eprint
	# Simple setup: from common import eprint
	# Usage: eprint(messages, v=1)

	# Don't forget they must end in 'm'
	BOLD = '\033[1m'
	WARNING = '\x1b[1;33;40m'
	FAIL = '\x1b[0;31;40m'
	END = '\x1b[0m'

	def __init__(self, verbose=0):
		self.level = verbose
		self.history = []

		#If string starts with '\n', look at history to make sure previous newlines don't exist
		self.autonewlines = True

	def newlines(self, num=1):
		"Print the required number of newlines after checking history to make sure they exist."
		lines = sum([1 for line in self.history[-num:] if not line.strip()])
		num -= lines
		if num:
			print('\n' * (num), end='')
		return num


	def eprint(self, *args, v=0, color=None, header=None, **kargs):
		'''Print to stderr
		Custom color example: color='1;33;40'
		More colors: https://stackoverflow.com/a/21786287/11343425
		'''
		verbose = v
		# Will print if verbose >= level
		if verbose < self.level:
			return 0

		if not color:
			if v == 2 and not color:
				color = f"{self.WARNING}"
			if v >= 3 and not color:
				color = f"{self.FAIL}" + f"{self.BOLD}"
		else:
			color = '\x1b[' + color + 'm'

		msg = ' '.join(map(str, args))
		if self.autonewlines:
			match = re.match('^\n*', msg)
			if match:
				num = self.newlines(match.span()[1])
				if num:
					#print('created', num, 'newlines', repr(msg[:64]))
					msg = msg.lstrip('\n')


		self.history += msg.splitlines()
		if len(self.history) > 64:
			self.history = self.history[64:]

		if header:
			msg = header + ' ' + msg
		if color:
			print(color + msg + f"{self.END}", file=sys.stderr, **kargs)
		else:
			print(msg, file=sys.stderr, **kargs)
		return len(msg)


def warn(*args, header="\n\nWarning:", delay=1 / 64):
	time.sleep(eprint(*args, header=header, v=2) * delay)


def itercount(start=0, step=1):
	"Save an import itertools"
	x = start
	while True:
		yield x
		x += step


qrun = quickrun		# pylint: disable=C0103
eprint = Eprinter(verbose=1).eprint     # pylint: disable=C0103
tman = ThreadManager()  # pylint: disable=C0103
TERM_WIDTH = get_terminal_size().columns
auto_cols = auto_columns    # pylint: disable=C0103

'''
&&&&%%%%%&@@@@&&&%%%%##%%%#%%&@@&&&&%%%%%%/%&&%%%%%%%%%%%&&&%%%%%&&&@@@@&%%%%%%%
%%%%%%%%&@&(((((#%%&%%%%%%%%%&@@&&&&&&%%%&&&&&%%%%%%%%%%%&&&&%&%#((((/#@@%%%%%%%
&&%%%%%%&@(*,,,,,,,/%&%%%%%%%&@@&&&&&%%&&&&%%&&%%%%%%%%%%&&&%#*,,,,,,*/&@&%%%%%%
%%%%%%%&@&/*,,,*,*,,*/%&%%%%%&@@&&&&&&%%&&&&&&&%%%%%%&%%%&&%*,,,,,,,,**#@&&%%%%%
&&&&&%%&@#(**********,*(#&%%%&@&&&&%%%%%%%%%&&&%%%%%%&%&&#*****,*******#@&&%%%%%
&&&%%%&&#/***/*****/*,**,*%&%&@@&&&&&&&&&&&&&&&%%%%%%&&#*,,,*/******/***(%&%%%%%
&&&%%%&%/*****///////**,,,,*/%%&&@@@@@@@@@@@@@@@@&&%#*,,,*,*(///////*****#%&%%%%
@@&%%#&#/,,,*/(//((((//**,,*/#&@@@@@&&&&&&&&&&@@@@@%(/*,,**/(/(((/(//*,,*(&&%%%%
&&&%##&#*,,,*////((((/*///(&@&@@&&&#%((//(/###%&@&@@@@#//**//(#(///***,.,/&&%%%%
%%%%%#%#*,,,**////(///((#&&&%@&%%(/*,,......,,/(#%&&&@@@%((/(/#(///**,,,,(&%%%%%
&&%%%#%%/,..***//(#(#%%&@@@&@%(*.,,..       ...,.,/#@&@@@&&%#(((///**,..,#%%%%%%
%&%%%%%#*,****/(##&@@@&@@@@&%*,....           ....,,(&@@@@@@&@&%((//****,(%%%%%%
%&%%%%%#/,**/#&@@@&@@@@@@@&(*,......    .     ..,..,.(&@@@@@@@&@@@&%#**,*(%%%%%%
&&%%%%#&#(#&@@@&@@@@@@@@%((#@@%&&((,,,,,..,,(**(%@@&@%##(&@@@@@@@@&&@@%#(%%%%%%%
&&&%%%%%&&&&&&@@@@@@%###%@(,%&/@@&(%(/*,..,*/%##&&,%@(*&@#((%&@@@@@@&&@&%%%%&&%%
&&%%%%%%&&&@@@@@@@@#((*#@%,#%%&@#%(/**//,****/(#%%%&&%*(@@*/#(&@@@@@@@&&%%%%%%%%
&&&%%%%%&@@@@&%#/,,,,*,(/%&@@&((%(*,*,,*,**,,*,*#%(#@@&%((**,,,,*#(%&@@&&%%%%%%%
&&&%%%%%@@@@%*/*,...,*,,/*#(//#****,***********,**/#/##(/*,*,...,*/*/&@@&%%&%%%%
&&%%%%%%&@@@(//,....,,*/****/,,/**************/***/,,//**/**,....,*//&@@&%%&%%%%
&&&%%%%%&@@%(/*,. ...,****/*/(//*%&@@&%%%%%%&&&&//*/(*/**/**......,/*#&@&%&&&&%%
&&%%%%%%&@@%(**,,....,/**/((/,#&&&&&%#((((((%&&&@&%/*/(/**/*,. ..,,*/((#@&&&&&&%
%&%%%%%%&&#(/**,..,,,***/((,./%&%&&&@&(/#((#@@&&&%&%,,/((*,/*,,..,,,///(%&%&&&&&
&&%%%%%%&#,**,.,..,,*(//(/,,.,&&&@#&@@##%(#&@&%%@&&#.,,/(((//*,,..,,**,*&%&&%&&&
&&%##%%%#/**,,,,..,*/((((*...,,#&##%(#%%&%%###%(%&/,.. **((((/,...,,,,**(%%#%%%&
&&%####(**,,,.,,.,,/(/(//*,,..../%&(##%&&&%%(#%&#, .. .**//(/(*,,..,.,,**/((#%%%
&&&%#///*,........,/(((//**,.   ,,(#%%%%%%&#%##**.   ,,*//((((*,........,*//(%%%
%%%%(/**...       .,/(((///*., .,*(#(%%%%%%%%##/*,..,,*///((/*.      .....**/(%%
%%%%#(,..          .,/((/(//****,/(((###%#%(#///**,,**/((/((*,          .,.,(%%%
&&%%%#/*...          ,*/(/(/((%%&#&#(/%./.*%(#%#%#&&(((/(/*,.          ..,**(&%%
&&%%%%(*.....          ..*((/**(#&&&&&&&%%%&%&&&%(/,*/((*..           .,..*(&&%%
&&%%%%&#*.      .        */(#/*,,*/((%#%%%%%((**,.*/(#(/,       .       ,(%&%%&%
%%%%%%&%#//**,..           .**(((*,...,,**,,..*,/((/*,.          ...,,//(#%%%%%%
%%%&&&%(/*,**,..,,.,..       .,,**//**,*,,,*,////*,,.        .,.,...,,,**//#%&%%
%%%&&%#/*,*,.    ...      ..         ...  ,.. .       .       ...   ..,,*/(#%&%%
&&&&&%(((*.*... . .*,.   .           .*%%#(,.          .    .*,. ..,.,,**/(%#&%%

Generated by https://github.com/SurpriseDog/Star-Wrangler
2021-05-30
'''
